#[LALR]
grammar<'input>;

use crate::ast;
use crate::tokens::Token;
use crate::lexer::{
    LexicalError,
    Location,
};

#[inline]
Comma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

pub Program: ast::Program<'input> =
    <declaration_list:DeclarationList> <function_list:FunctionList> => ast::Program {
        declaration_list,
        function_list,
    };

pub DeclarationList
    = Declaration*;

pub FunctionList
    = Function*;

pub Declaration: ast::Declaration<'input> =
    "var" <variable_list:VariableList> ";" => ast::Declaration {
        variable_list,
    };

pub VariableList =
    Comma<Variable>;

pub Variable: ast::Variable<'input> =
    <name:"identifier"> ":" <variable_type:VariableType> => ast::Variable {
        name,
        variable_type,
    };

pub VariableType: ast::VariableType = {
    "int" => ast::VariableType::Int,
    "real" => ast::VariableType::Real,
    "int" "[" "]" => ast::VariableType::IntVector{has_size: false, size: 0},
    "int" "[" <n:"int_literal"> "]" => ast::VariableType::IntVector {
        has_size: true,
        size: n,
    },
    "real" "[" "]" => ast::VariableType::RealVector{has_size: true, size: 0},
    "real" "[" <n:"int_literal"> "]" => ast::VariableType::RealVector {
        has_size: true,
        size: n,
    },
};

pub Function: ast::Function<'input> =
    <return_type:VariableType> "func" <name:"identifier"> "(" <parameter_list:ParameterList> ")" <declaration_list:DeclarationList> "endfunc" =>
        ast::Function {
            return_type,
            name,
            parameter_list,
            declaration_list,
        };

pub ParameterList = VariableList;

extern {
    type Location = Location;
    type Error = LexicalError;

    enum Token<'input> {
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        ":" => Token::Colon,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        ":=" => Token::Assign,
        "=" => Token::Equal,
        "<>" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "var" => Token::Var,
        "func" => Token::Func,
        "endfunc" => Token::EndFunc,
        "return" => Token::Return,
        "to" => Token::To,
        "by" => Token::By,
        "and" => Token::And,
        "mod" => Token::Mod,
        "div" => Token::Div,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "endif" => Token::EndIf,
        "for" => Token::For,
        "endfor" => Token::EndFor,
        "or" => Token::Or,
        "do" => Token::Do,
        "print" => Token::Print,
        "read" => Token::Read,
        "while" => Token::While,
        "endwhile" => Token::EndWhile,
        "not" => Token::Not,
        "int" => Token::Int,
        "real" => Token::Real,
        "identifier" => Token::Identifier(<&'input str>),
        "string_literal" => Token::StringLiteral(<&'input str>),
        "int_literal" => Token::IntLiteral(<i64>),
        "real_literal" => Token::RealLiteral(<f64>),
    }
}